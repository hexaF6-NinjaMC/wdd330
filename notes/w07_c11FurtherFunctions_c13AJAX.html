<!DOCTYPE html>
<html lang="en-us">
    <head>
        <title>Weekly Notes</title>
        <meta charset="UTF-8">
    </head>

    <body>
        <header>
            <h1>This is the header for the Week <span class="weekNumber">07</span>'s Notes.</h1>
        </header>
        
        <main>
            <a href="../index.html"> &Lt; Go Back to Portal</a>
            <h2>The Notes:</h2>
<h2>Function Properties and Methods:</h2><p>Functions are first-class objects; therefore, they can have properties and methods themselves. For example, functions have a length property that returns the number of parameters they require.</p><h3>Call() and Apply() methods:</h3><p>The <em>call()</em> method is used to set the value of <strong><em>this</em></strong> inside a function to an <strong>object that is provided as the first argument.</strong></p><p>For example:<br />	<em>function sayHello() {</em></p><p><em>		return `Hello, my name id ${ this.name }.`;</em></p><p><em>	}</em></p><p><em>	</em>refers to an unspecific object called <em>this</em> that has a property called <em> name.</em></p><p>By creating some objects containing the <em>name</em> property, then using the <em>call()</em> function to invoke the <em>sayHello()</em> function, we would provide the object as an argument for <em>this</em>:<br />	<em>const </em><strong><em>clark</em></strong><em> = { name: {{ Clark }} };<br />	const </em><strong><em>bruce</em></strong><em> = { name: {{ Bruce }} };</em></p><p><em>	sayHello.call(</em><strong><em>clark</em></strong><em>);<br />	&lt;&lt; {{ Hello, my name is Clark. }}</em></p><p><em>	sayHello.call(</em><strong><em>bruce</em></strong><em>);<br />	&lt;&lt; {{ Hello, my name is Bruce. }}</em></p><p>If the function that is called requires any parameters, these need to be provided as arguments after the first argument (the value of <em>this</em>). If <em>this</em> is not referred to within the function, the<em> </em>first argument of <em>call()</em> would then need to be <strong><em>null</em></strong>.</p><p>The <em>apply()</em> method works in the same way as <em>call()</em>, except the arguments of the function are provided as an Array, even if there is only one argument.</p><p>	<em>square.apply(null, [4])<br />	&lt;&lt; 16</em></p><p>This can be useful if the data for the argument is already an Array, although unnecessary due to ES6 spread operators.</p><h3>Custom Properties:</h3><p>Functions can have custom properties. For example, you can add a <em>description</em> property to describe what a function does:</p><p>	<em>square.description = {{ Squares a number that is provided as an argument. }}<br />	&lt;&lt; {{ Squares a number that is provided as an argument. }}</em></p><h4>Memoization (or Result Caching):</h4><p>If a function takes some time to compute a value, save it using the <em>cache</em> property. If the same argument is used again later, return the value from the cache, rather than recomputing the value.</p><h2>IIFEs (Immediately-Invoked Function Expressions) - Iffies:</h2><p>IIFEs are anonymous functions that are invoked as soon as defined. This is accomplished by wrapping the function definition within parentheses, then adding another pair directly after, like so:</p><p>	<em>(function() {</em></p><p><em>		const </em><strong><em>temp</em></strong><em> = {{ World }};<br />		console.log(`Hello ${temp}!`);</em></p><p><em>	})</em><strong><em>();</em></strong></p><p><strong><em>	</em></strong><em>&lt;&lt; {{ Hello World! }}</em></p><p>Doing this will help not to<em> overcrowd</em> the global namespace/scope with too many variable names.</p><h2>Generators:</h2><p>ES6 introduced support for generators that maintain the state of a value. To define them, place an asterisk (*) after the <em>function</em> declaration, like so:</p><p>	<em>function</em><strong><em>*</em></strong><em> exampleGenerator() {<br />		// code for the generator here.<br />	}</em></p><p>This will not run the code in the function, but return a <strong><em>Generator</em></strong> object to create an iterator that implements a <em>next() </em>method that returns a value every time the <em>next()</em> method is called.</p><p>Generator functions sue a special <em>yield</em> keyword to return a value, rather the normal <em>return</em> keyword. The difference is <em>yield</em> stores the state of the value for the next time <em>yield</em> is called. This also pauses the execution of a loop post-<em>yield</em>, until the <em>next()</em> method is called again.</p><p>You can also iterate over the generator using loops, like <em>for</em> and <em>while</em>.</p><h2>Functional Programming:</h2><h3>Pure functions:</h3><p>A key aspect of functional programming is the use of {{ pure functions }} that abide by the following rules:</p><ol><li>The return value of a pure function should only depend on the values provided as arguments. It doesn't rely on values from somewhere else in the program.</li><li>There are no side-effects. A pure function doesn't change any values or data elsewhere in the program. It only makes non-destructive data transformations and returns new values, rather than altering any of the underlying data.</li><li>Referential transparency. Given the same arguments, a pure function will always return the same result.</li></ol><p>In order to follow these rules, any pure function must have:</p><ul><li>At least one argument; otherwise, the return value must depend on something other than the arguments of the function, breaking the first rule</li><li>A return value; otherwise, there is no point in the function (unless it has changed something else in the program - in which case, it is broken the 'no side-effects' rule).</li></ul><p>Pure functions help to make functional programming code more concise and predictable than in other programming styles</p><h2>Clients and Servers:</h2><h3>Request Interface:</h3><p>Request objects are created using the <em>Request()</em> constructor, and include the following properties:</p><ul><li><em>Url</em>: The URL of the requested resource (the only property that is required).</li><li><em>Method</em>: a string that specifies which HTTP method should be used for the request. By default, this is 'GET'.</li><li><em>Headers</em>: This is a Headers object (see later section) that provides details of the request's headers.</li><li><em>Mode</em>: Allows you to specify if CORS is used or not. CORS is enabled by default.</li><li><em>Cache</em>: Allows you to specify how the request will use the browser's cache. For example, you can force it to request a resource and update the cache with the result, or you can force it to only look in the cache for the resource.</li><li><em>Credentials</em>: Lets you specify if cookies should be allowed with the request.</li><li><em>Redirect</em>: Specifies what to do if the response returns a redirect. There is a choice of three values: 'follow' (the redirect is followed), 'error' (an error is thrown) or 'manual' (the user has to click on a link to follow the redirect).</li></ul><h4>Headers:</h4><p>HTTP headers are used to pass on any additional information about a request or response. Typical information contained in headers includes the file-type of the resource, cookie information, authentication information and when the resource was last modified.</p><p>The Fetch API introduced a Headers interface, which can be used to create a Headers object, which can then be added as a property of Request and Response objects.</p><p>A new Headers instance is created using a constructor function, as seen in the example below:</p><p><em>	const </em><strong><em>headers</em></strong><em> = new Headers();</em></p><p>	and can be given optional arguments with initial header values:</p><p><em>	const</em><strong><em> headers</em></strong><em> = new Headers({ {{ Content-type }}:  {{ text/plain }}, {{ Accept-Charset }}: {{ utf-8 }}, {{ Accept-Encoding }}: {{ gzip,deflate }} });</em></p><p>Headers objects also have the following properties and methods to access information about the headers, as well as edit the header information itself:</p><ul><li><em>has():</em> Can be used to check if the headers object contains the header provided as an argument; returns Boolean.</li><li><em>get():</em> Returns the value of the header provided as an argument (like {{ text/plain }}).</li><li><em>set():</em> Can be used to set a value of an already-existing header, or create a new header with the value provided as an argument if it does not already exist:<ul><li><em>headers.set({{ Content-Type }}, {{ application/json }});</em></li></ul></li><li><em>append():</em> Adds a new header to the headers object.</li><li><em>delete():</em> Removes the header provided as an argument.</li><li><em>keys(), values(), </em>and<em> entries():</em> Iterators that can be used to iterate over the headers key, values, or entries (like key-value pairs in JS or dictionaries in Python).</li></ul>

        </main>

        <footer>
            <h3>This is the footer for the Week <span class="weekNumber">07</span>'s Notes.</footer>
        </footer>
    </body>
</html>